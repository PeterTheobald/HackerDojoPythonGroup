Notes for Tuesday 2/17, 2026

https://github.com/keon/algorithms

Meta teamopen sourced CinderX
https://github.com/facebookincubator/cinderx
2-5x speed improvement, especially around DJango
Meta was also behind the NoGil Python improvements (PyTorch team)

Free Coding Interview Books:
https://github.com/shahri23/books?search=1

Main Topic:
Python Protocols

type annotations are patterned after statically typed languages like Java


proto1.py:
```
def add(a: float, b: float) -> float:
    return a+b

add(5.4,1.1)
add(5,1)
add("5","1")
```

```
uv run python proto1.py
uvx ty check proto1.py
```

Python is not statically typed. It is dynamic:

```
numbers = [1, 2, 3]
person = ("Jane", 25, "Python Dev")
letters = "abc"
ordinals = {"one": "first", "two": "second", "three": "third"}
even_digits = {2, 4, 6, 8}

containers = [numbers, person, letters, ordinals, even_digits]

for container in containers:
    for element in container:
        print(element, end=" ")
    print()
```

Duck typing: If it quacks like a Duck, that is good enough to call it a Duck
ie: If a type supports the right methods we can use it

proto3.py:
```
class Duck:
    def quack(self):
        return "The duck is quacking!"

def make_it_quack(duck: Duck) -> str:
    return duck.quack()

class Person:
    def quack(self):
        return "The person is imitating a duck quacking!"

print(make_it_quack(Duck()))

print(make_it_quack(Person()))
```

You could fix this by making all of the classes inherit from the same parent super class
like Java would do:

```
class QuackingThing:
    def quack(self):
        raise NotImplementedError(
            "Subclasses must implement this method"
        )

class Duck(QuackingThing):
    def quack(self):
        return "The duck is quacking!"

class Person(QuackingThing):
    def quack(self):
        return "The person is imitating a duck quacking!"

def make_it_quack(duck: QuackingThing) -> str:
    return duck.quack()

print(make_it_quack(Duck()))

print(make_it_quack(Person()))

print( isinstance( Duck(), QuackingThing))
print( isinstance( Person(), QuackingThing))
```

But that gets very messy when a class implements many different interfaces,
like Iterable and can ask the size() of and a Callable, and is Reversible, etc.

Java handles this with multiple inheritance; You literally make the class a child
of dozens of different classes. That becomes a terrible mess.
Classes may have nothing in common except they can be iterated or called or asked
their size and they have to be tightly bound together as "children" of the same
parent class.

Python handles this with Duck Typing. If a class defines the necessary methods, then 
it can be used in that way.
For example, any class that implements \__iter\__() and \__next\__ is considered an Iterator.
It isn't explicitly declared, it just works.
Any class that implements \__len\__() can be asked the size.
Any class that implements \_call\__() can be called like a function x()

But how do we get the benefit of type annotations with Duck Typing?
How can we check the types of classes that implement an interface but don't explictly declare it anywhere?

We use prototypes.

proto4.py
```
from typing import Protocol

class Quacker(Protocol):
  def make_it_quack(self, x):
    ...

class Duck():
    def quack(self):
        return "The duck is quacking!"

class Person():
    def quack(self):
        return "The person is imitating a duck quacking!"

def make_it_quack(animal: Quacker) -> str:
    return animal.quack()

print(make_it_quack(Duck()))

print(make_it_quack(Person()))
```

There are more ways you can use Protocols, look up Custom Protocols, 
Generic Protocols, Subprotocols, Recursive Protocols, etc...

Here are some built-in protocols that are already defined for you
to use in Type Annotations in Python:

```
Container	.__contains__()
Hashable	.__hash__()
Iterable	.__iter__()
Iterator	.__next__() and .__iter__()
Reversible	.__reversed__()
Generator	.send(), .throw(), .close(), .__iter__(), and .__next__()
Sized	.__len__()
Callable	.__call__()
Collection	.__contains__(), .__iter__(), and .__len__()
Sequence	.__getitem__(), .__len__(), .__contains__(), .__iter__(), .__reversed__(), .index(), and .count()
MutableSequence	.__getitem__(), .__setitem__(), .__delitem__(), .__len__(), .insert(), .append(), .clear(), .reverse(), .extend(), .pop(), .remove(), and .__iadd__()
ByteString	.__getitem__() and .__len__()
Set	.__contains__(), .__iter__(), .__len__(), .__le__(), .__lt__(), .__eq__(), .__ne__(), .__gt__(), .__ge__(), .__and__(), .__or__(), .__sub__(), .__xor__(), and .isdisjoint()
MutableSet	.__contains__(), .__iter__(), .__len__(), .add(), .discard(), .clear(), .pop(), .remove(), .__ior__(), .__iand__(), .__ixor__(), and .__isub__()
Mapping	.__getitem__(), .__iter__(), .__len__(), .__contains__(), .keys(), .items(), .values(), .get(), .__eq__(), and .__ne__()
MutableMapping	.__getitem__(), .__setitem__(), .__delitem__(), .__iter__(), .__len__(), .pop(), .popitem(), .clear(), .update(), and .setdefault()
AsyncIterable	.__aiter__()
AsyncIterator	.__anext__() and .__aiter__()
AsyncGenerator	.asend(), .athrow(), .aclose(), .__aiter__(), and .__anext__()
Buffer	.__buffer__()
```


